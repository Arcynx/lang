#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "Parser/AST/ast.h"
#include "Lexer/lexer.h"

char* header = "; --- Generated by Flouride Compiler ---\n\n";

char* data_section = "section .data\n";

char* text_section = NULL;

/* Compiler */

int compile(ASTNode *node)
{
    text_section = malloc(256);
    text_section[0] = '\0';

    addInstruction("section text\n\nglobal _start\n\n_start:\n");

    ASTNodeType before;
    printf("----------------------------------\nCompiling...\n");
    int i = 0;

    while (node->type != AST_EOF && node->type != NULL && node)
    {
        if (node->type == AST_FUNCTION_DECLARATION)
        {
            ASTFunctionDeclaration *func = (ASTFunctionDeclaration *)node;
            printf("Found Function Declaration:\n   Name: \"%s\",\n", func->name);
            printf("   Parameters: %d\n", func->param_count);
            printf("   Block:\n");

            ASTNode *block = func -> body;
            compile_block(block);
        }

        i++;

        printf("AST INDEX: \"%d\" With Type Of: \"%d\"\n", i, node->type);

        before = node->type;
        node = node->next;
    }

    size_t size = strlen(header) + strlen(data_section) + strlen(text_section) + 1;
    char* end_buf = malloc(size);
    if (end_buf == NULL)
    {
        perror("Failed to allocate memory");
        return;
    }

    end_buf[0] = '\0';

    strcat(end_buf, header);
    strcat(end_buf, data_section);
    strcat(end_buf, text_section);

    writeASM("build/assembly/1.asm", end_buf);

    printf("----------------------------------\nEND OF COMPILING!.\n");

    return 0;
}

int compile_block(ASTNode *block)
{
    printf("--- BLOCK BEGIN ---\n");

    while (block->type != AST_EOF && block->type != NULL && block)
    {
        switch (block->type)
        {
        case AST_RETURN_STATEMENT:
            ASTReturnStatement* ret = (ASTReturnStatement*) block;

            printf("    RETURN STATEMENT\n");
            break;

        case AST_FUNCTION_CALL:
            ASTFunctionCall* call = (ASTFunctionCall*) block;

            printf("    Running Function: \"%s\"\n", call->name);

            /* Function Arguments */

            for (int i = 0; i < call->arg_count; i++)
            {
                printf("    arg type: %d\n");
                if (call->arguments[i]->type == AST_STRING_LITERAL)
                    printf("    STRING\n");
            }
            
            char instruction[64];
            sprintf(instruction, "call %s\n", call->name);
            addInstruction(instruction);

            break;
        
        default:
            break;
        }

        block = block->next;
    }

    printf("--- BLOCK END ---\n");

    return 0;
}

void addInstruction(const char* instruction)
{
    if (text_section == NULL) 
    {
        text_section = malloc(256);
        if (text_section == NULL) 
        {
            perror("Failed to allocate memory for text_section");
            return;
        }
        text_section[0] = '\0';
    }

    size_t new_size = strlen(text_section) + strlen(instruction) + 1;
    char* temp = realloc(text_section, new_size);

    if (temp == NULL) 
    {
        perror("Failed to allocate memory");
        return;
    }

    text_section = temp;

    strcat(text_section, instruction);
}


void writeASM(const char *filename, const char *content) 
{
    FILE *file = fopen(filename, "w");

    if (!file) 
    {
        perror("Failed to open file");
        return;
    }

    fprintf(file, "%s", content); 

    fclose(file);
}